# -*- coding: utf-8 -*-

"""
/***************************************************************************
 UnpivotSelectedFeaturesAttributes
                                 A QGIS plugin
 This script rotates the attribute table of selected features by transforming columns into rows (unpivot). The result is
 added as a temporary layer to the map.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-01-15
        copyright            : (C) 2024 by AUGMENTERRA GmbH
        email                : office@augmenterra.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

from qgis.PyQt.QtCore import (QCoreApplication,
                              QVariant,
                              QRegExp,
                              Qt,
                              QDate)
from qgis.core import (QgsProcessing,
                       QgsFeatureSink,
                       QgsProcessingAlgorithm,
                       QgsProcessingParameterVectorLayer,
                       QgsProcessingParameterFeatureSink,
                       QgsProcessingParameterBoolean,
                       QgsProcessingException,
                       QgsFeature,
                       QgsField,
                       QgsVectorLayer,
                       QgsProject)
import pandas as pd


class UnpivotSelectedFeaturesAttributes(QgsProcessingAlgorithm):
    INPUT = 'INPUT'
    OUTPUT = 'OUTPUT'

    def tr(self, string):
        """
        Returns a translatable string with the self.tr() function.
        """
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return UnpivotSelectedFeaturesAttributes()

    def name(self):
        return 'unpivotSelectedFeaturesAttributes'

    def displayName(self):
        return self.tr('Unpivot selected features attributes')

    def group(self):
        return self.tr('AUGMENTERRA scripts')

    def groupId(self):
        return 'augmenterrascripts'

    def tags(self):
        return (QCoreApplication.translate("UnpivotSelectedFeaturesAttributes", 'POSTGIS layer', 'unpivot')).split(',')

    def __init__(self):
        super().__init__()

    def initAlgorithm(self, config=None):
        """
        Here we define the inputs and output of the algorithm, along
        with some other properties.
        """

        self.addParameter(
            QgsProcessingParameterVectorLayer(
                self.INPUT,
                self.tr('Input vectorlayer'),
                [QgsProcessing.TypeVectorPoint]
            )
        )

        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT,
                self.tr('Temporary result layer')
            )
        )

    def flags(self):
        """Here we let QGIS know our algorithm supports edit-in-place"""
        return super().flags() | QgsProcessingAlgorithm.FlagSupportsInPlaceEdits

    def processAlgorithm(self, parameters, context, feedback):

        p_layer = self.parameterAsVectorLayer(parameters, self.INPUT, context)
        if p_layer is None:
            raise QgsProcessingException(self.invalidSourceError(parameters, self.INPUT))

        selected_features = p_layer.selectedFeatures()

        selected_features_info = []
        date_col, val_col, col_names = [], [], []
        info_fields = {}
        ps_fields = p_layer.fields()

        # Identify fields containing information to be displayed
        for idx, fld in enumerate(ps_fields):
            if QRegExp("D\\d{8}", Qt.CaseInsensitive).indexIn(fld.name()) < 0:
                # info fields are all except those containing dates
                info_fields[idx] = fld
                col_names.append(info_fields[idx].name())
            else:
                for i, feature in enumerate(selected_features):
                    feature_object = QgsFeature(feature)
                    feature_id = feature.id()
                    attrs = feature_object.attributes()

                    if isinstance(attrs[idx], float):
                        date_col.append(QDate.fromString(fld.name()[1:], "yyyyMMdd").toPyDate())
                        val_col.append(float(attrs[idx]))

                    selected_features_info.append((feature_id, attrs))

        # Create an empty DataFrame with the correct columns
        df_result = pd.DataFrame(columns=col_names + ['date', 'value'])

        # Populate the DataFrame with selected feature attributes
        for i, (feature_id, attrs) in enumerate(selected_features_info):
            row_data = [attrs[i] for i in info_fields]
            date_value = date_col[i] if i < len(date_col) else None
            velo_value = val_col[i] if i < len(val_col) else None

            try:
                new_row = pd.Series(row_data + [date_value, velo_value], index=col_names + ['date', 'value'])
                df_result = df_result._append(new_row, ignore_index=True)
            except Exception as e:
                print(f"Error at iteration {i}: {e}")

        # Remove rows with NaN values in 'date' or 'velo' columns
        df_result = df_result.dropna(subset=['date', 'value'])
        # Convert the 'date' column to datetime if it's currently represented as 'object'
        df_result['date'] = pd.to_datetime(df_result['date'], errors='coerce')

        # Convert the 'date' column to string representation
        df_result['date'] = df_result['date'].dt.strftime('%Y-%m-%d')
        # Reset the index to ensure it is unique
        df_result = df_result.dropna(subset=['date', 'value'])

        # Creation of my QgsVectorLayer with no geometry
        temp = QgsVectorLayer("none", "result_processing", "memory")
        temp_data = temp.dataProvider()

        # Start of the edition
        temp.startEditing()

        # Get data types of each column
        column_types = df_result.dtypes

        # Map Pandas data types to QgsField types
        qgs_type_mapping = {
            'int64': QVariant.Int,
            'float64': QVariant.Double,
            'object': QVariant.String,
            'datetime64[ns]': QVariant.DateTime
        }

        # Convert Pandas data types to QgsField types
        qgs_field_types = column_types.apply(lambda x: qgs_type_mapping.get(str(x), QVariant.String))

        # Creation of my fields
        for col_name, qgs_type in zip(column_types.index, qgs_field_types):
            field = QgsField(col_name, qgs_type)
            temp.addAttribute(field)

        # Update
        temp.updateFields()

        # Addition of features
        for _, row in df_result.iterrows():
            f = QgsFeature()
            attrs = []
            for value, qgs_type in zip(row, qgs_field_types):
                attrs.append(value if pd.notnull(value) else None)
            f.setAttributes(attrs)
            temp.addFeature(f)

        # Saving changes and adding the layer
        temp.commitChanges()
        QgsProject.instance().addMapLayer(temp)

        # Return the output layer
        return {self.OUTPUT: temp.id()}
